import pandas as pdimport osimport psycopg2import urllib.parsefrom urllib.parse import urlparseimport urllib.requestimport jsonimport requestsfrom apscheduler.schedulers.blocking import BlockingSchedulerfrom bs4 import BeautifulSoupimport reimport loggingfrom datetime import datetimefrom dateutil.tz import tzlocalfrom sqlalchemy import create_engineimport lxmlfrom datetime import dateimport numpy as npimport html5libimport randomfrom itertools import repeatfrom scipy import statsimport iofrom urllib.parse import urljoin'''logging.basicConfig() DATABASE_URL = 'postgres://wgmfozowgyxule:8c7255974c879789e50b5c05f07bf00947050fbfbfc785bd970a8bc37561a3fb@ec2-44-195-16-34.compute-1.amazonaws.com:5432/d5o6bqguvvlm63'print(DATABASE_URL)#replace 'postgres' with 'postgresql' in the database URL since SQLAlchemy stopped supporting 'postgres' SQLALCHEMY_DATABASE_URI = DATABASE_URL.replace('postgres://', 'postgresql://')conn = psycopg2.connect(SQLALCHEMY_DATABASE_URI, sslmode='require')engine = create_engine(SQLALCHEMY_DATABASE_URI)'''now = datetime.now(tzlocal()).strftime('%Y-%m-%d %H:%M:%S %Z')powers = {'B': 10 ** 9, 'K': 10 ** 3, 'M': 10 ** 6, 'T': 10 ** 12}# add some more to powers as necessarydef formatstr(s):    try:        power = s[-1]        if (power.isdigit()):            return s        else:            return float(s[:-1]) * powers[power]    except TypeError:        return sdef exportScratcherRecs():    """    Scrapes Missouri Lottery data.    1. Gets list of games from /scratchers-list.do    2. Drills down to /scratchers.do?method=d&game=XXX for full tables.    """    base_url = "https://www.molottery.com"    list_url = "https://www.molottery.com/scratchers-list.do"        headers = {        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'    }    print(f"Fetching MO game list from: {list_url}")    tixtables = pd.DataFrame()    scratchersall_list = []    # BAD NAMES BLOCKLIST    BAD_NAMES = ["Game Details", "Search", "View", "Scratchers", "Details", "More Info", "See Details"]    try:        r = requests.get(list_url, headers=headers)        r.raise_for_status()        soup = BeautifulSoup(r.content, 'html.parser')                # Find all game links        game_links = soup.find_all('a', href=re.compile(r'scratchers\.do\?method=d&game='))                unique_game_links = {}        for link in game_links:            href = link['href']            full_url = urljoin(base_url, href)                        # Extract Game ID            match = re.search(r'game=(\d+)', href)            if match:                game_id = match.group(1)                                # Try to get name from link text (only if it's not generic)                link_text = link.get_text(strip=True)                candidate_name = None                                if link_text and len(link_text) > 2 and link_text not in BAD_NAMES:                     candidate_name = link_text                                if game_id not in unique_game_links:                    unique_game_links[game_id] = {'url': full_url, 'name': candidate_name}                else:                    # Update if we found a valid name and previously had None or a generic one                    if candidate_name and (unique_game_links[game_id]['name'] is None):                        unique_game_links[game_id]['name'] = candidate_name        print(f"Found {len(unique_game_links)} potential games.")        for game_id, game_info in unique_game_links.items():            detail_url = game_info['url']            list_candidate_name = game_info['name']                        try:                # --- FETCH DETAIL PAGE ---                detail_r = requests.get(detail_url, headers=headers)                detail_soup = BeautifulSoup(detail_r.content, 'html.parser')                full_text = detail_soup.get_text(" ", strip=True)                                # --- DETERMINE GAME NAME (STRICT PRIORITY) ---                game_name = "Unknown Game"                                # Helper to clean and validate names                def is_valid_name(n):                    if not n: return False                    n_clean = n.strip()                    if len(n_clean) < 2: return False                    if any(bad in n_clean for bad in BAD_NAMES): return False                    return True                # Priority 1: Page <title> tag (Usually "Game Name - Missouri Lottery")                if not is_valid_name(game_name) or game_name == "Unknown Game":                    if detail_soup.title:                        title_text = detail_soup.title.get_text(strip=True)                        # Remove suffix                        clean_title = title_text.split("- Missouri")[0].strip()                        if is_valid_name(clean_title):                            game_name = clean_title                # Priority 2: Breadcrumb (Last item is usually the game name)                if not is_valid_name(game_name) or game_name == "Unknown Game":                    # Look for standard breadcrumb classes or structures                    breadcrumbs = detail_soup.select(".breadcrumb li, .breadcrumbs li")                    if breadcrumbs:                        last_crumb = breadcrumbs[-1].get_text(strip=True)                        if is_valid_name(last_crumb):                            game_name = last_crumb                # Priority 3: Image Alt Text                if not is_valid_name(game_name) or game_name == "Unknown Game":                    img_tag = detail_soup.find('img', src=re.compile(r'/images/scratchers/'))                    if img_tag and img_tag.get('alt'):                        alt_text = img_tag['alt']                        if is_valid_name(alt_text):                            game_name = alt_text                                # Priority 4: List Page Name (Fallback)                if (not is_valid_name(game_name) or game_name == "Unknown Game") and is_valid_name(list_candidate_name):                    game_name = list_candidate_name                # Cleanup final name                game_name = game_name.replace('MOLottery.com', '').strip()                # --- EXTRACT PRICE ---                price = 0.0                price_match = re.search(r'Ticket Price:\s*\$(\d+)', full_text, re.IGNORECASE)                if price_match:                    price = float(price_match.group(1))                                # --- EXTRACT DATES ---                start_date = None                start_match = re.search(r'Start Date:\s*([A-Za-z]{3}\s\d{1,2},\s\d{4})', full_text)                if start_match:                    try:                        dt = datetime.strptime(start_match.group(1), '%b %d, %Y')                        start_date = dt.strftime('%Y-%m-%d')                    except: pass                                    # --- EXTRACT ODDS ---                overall_odds = 0.0                odds_match = re.search(r'1 in ([\d\.]+)', full_text)                if odds_match:                    overall_odds = float(odds_match.group(1))                # --- EXTRACT IMAGE ---                gamePhoto = None                img_tag = detail_soup.find('img', src=re.compile(r'/images/scratchers/'))                if img_tag:                    gamePhoto = urljoin(base_url, img_tag['src'])                print(f"  > Processing: {game_name} (#{game_id})")                # --- EXTRACT PRIZE TABLE ---                tables = detail_soup.find_all('table')                prize_table_df = pd.DataFrame()                                for tbl in tables:                    try:                        df = pd.read_html(io.StringIO(str(tbl)))[0]                        cols_map = {}                        for col in df.columns:                            c_low = str(col).lower()                            if 'prize' in c_low and 'level' in c_low:                                cols_map[col] = 'prizeamount'                            elif 'total' in c_low:                                cols_map[col] = 'Winning Tickets At Start'                            elif 'unclaimed' in c_low:                                cols_map[col] = 'Winning Tickets Unclaimed'                                                if 'prizeamount' in cols_map.values() and 'Winning Tickets Unclaimed' in cols_map.values():                            df.rename(columns=cols_map, inplace=True)                            prize_table_df = df                            break                    except:                        continue                if prize_table_df.empty:                    print(f"    - No prize table found for {game_name}. Skipping.")                    continue                # --- CLEAN DATA ---                if 'prizeamount' in prize_table_df.columns:                    prize_table_df['prizeamount'] = (                        prize_table_df['prizeamount']                        .astype(str)                        .str.replace(r'[$,]', '', regex=True)                        .str.replace(r'Ticket', '0', regex=True, case=False)                        .str.replace(r'Free', '0', regex=True, case=False)                        .str.strip()                    )                    prize_table_df['prizeamount'] = pd.to_numeric(prize_table_df['prizeamount'], errors='coerce').fillna(0)                for col in ['Winning Tickets At Start', 'Winning Tickets Unclaimed']:                    if col in prize_table_df.columns:                        prize_table_df[col] = (                            prize_table_df[col]                            .astype(str)                            .str.replace(r'[,]', '', regex=True)                            .str.strip()                        )                        prize_table_df[col] = pd.to_numeric(prize_table_df[col], errors='coerce').fillna(0)                    else:                        prize_table_df[col] = 0                if prize_table_df['Winning Tickets At Start'].sum() == 0:                     prize_table_df['Winning Tickets At Start'] = prize_table_df['Winning Tickets Unclaimed']                prize_table_df['gameNumber'] = game_id                prize_table_df['gameName'] = game_name                prize_table_df['price'] = price                prize_table_df['dateexported'] = date.today()                                topprize = prize_table_df['prizeamount'].max()                topprizestarting = 0                topprizeremain = 0                                if topprize > 0:                    top_rows = prize_table_df[prize_table_df['prizeamount'] == topprize]                    if not top_rows.empty:                        topprizestarting = top_rows['Winning Tickets At Start'].iloc[0]                        topprizeremain = top_rows['Winning Tickets Unclaimed'].iloc[0]                                topprizeavail = "Available" if topprizeremain > 0 else "Claimed"                                tixtables = pd.concat([tixtables, prize_table_df], ignore_index=True)                scratchersall_list.append({                    'gameNumber': game_id,                    'gameName': game_name,                    'price': price,                    'topprize': topprize,                    'overallodds': overall_odds,                    'topprizestarting': topprizestarting,                    'topprizeremain': topprizeremain,                    'topprizeavail': topprizeavail,                    'startDate': start_date,                    'endDate': None,                    'lastdatetoclaim': None,                    'gameURL': detail_url,                    'gamePhoto': gamePhoto,                    'dateexported': date.today(),                    'extrachances': None,                    'secondChance': None,                    'topprizeodds': 0                 })            except Exception as e:                print(f"    - Error processing {detail_url}: {e}")                continue        except Exception as e:        print(f"Critical Error scraping MO list: {e}")        return None, None    # --- SAVE OUTPUTS ---    if not scratchersall_list:        print("No data collected.")        return None, None    scratchersall = pd.DataFrame(scratchersall_list)    scratchersall.to_csv("./MOscratcherslist.csv", encoding='utf-8', index=False)    tixtables.to_csv("./MOscratchertables.csv", encoding='utf-8', index=False)    scratchersall = tixtables.loc[:,['price', 'gameName', 'gameNumber', 'topprize', 'overallodds', 'topprizestarting', 'topprizeremain',                               'topprizeavail', 'extrachances', 'secondChance', 'startDate', 'endDate', 'lastdatetoclaim', 'dateexported','gameURL']]    scratchersall = scratchersall.loc[scratchersall['gameNumber']                                      != "Coming Soon!", :]    scratchersall = scratchersall.drop_duplicates()    # save scratchers list    #scratchersall.to_sql('MOscratcherlist', engine, if_exists='replace')    scratchersall.to_csv("./MOscratcherslist.csv", encoding='utf-8')    # Create scratcherstables df, with calculations of total tix and total tix without prizes    scratchertables = tixtables.loc[:,['gameNumber', 'gameName', 'prizeamount',                                 'Winning Tickets At Start', 'Winning Tickets Unclaimed', 'dateexported']]    scratchertables.to_csv("./MOscratchertables.csv", encoding='utf-8')    scratchertables = scratchertables.loc[scratchertables['gameNumber']                                          != "Coming Soon!", :]    # Get sum of tickets for all prizes by grouping by game number and then calculating with overall odds from scratchersall    # Select columns first, then groupby and aggregate    cols_to_sum = ['Winning Tickets At Start', 'Winning Tickets Unclaimed']    gamesgrouped = scratchertables.groupby(        by=['gameNumber', 'gameName', 'dateexported'], group_keys=False)[cols_to_sum].sum().reset_index() # reset_index() without levels works here        gamesgrouped = gamesgrouped.merge(scratchersall.loc[:, [                                      'gameNumber', 'price', 'topprizestarting', 'topprizeremain', 'overallodds']], how='left', on=['gameNumber'])    gamesgrouped.loc[:, 'Total at start'] = gamesgrouped['Winning Tickets At Start'] * \        gamesgrouped['overallodds'].astype(float)    gamesgrouped.loc[:, 'Total remaining'] = gamesgrouped['Winning Tickets Unclaimed'] * \        gamesgrouped['overallodds'].astype(float)    gamesgrouped.loc[:, 'Non-prize at start'] = gamesgrouped['Total at start'] - \        gamesgrouped['Winning Tickets At Start']    gamesgrouped.loc[:, 'Non-prize remaining'] = gamesgrouped['Total remaining'] - \        gamesgrouped['Winning Tickets Unclaimed']    try:        gamesgrouped['topprizeodds'] = gamesgrouped['Total remaining'] / gamesgrouped['topprizeremain']    except ZeroDivisionError:        gamesgrouped['topprizeodds'] = 0    gamesgrouped.loc[:, ['price', 'topprizeodds', 'overallodds', 'Winning Tickets At Start', 'Winning Tickets Unclaimed']] = gamesgrouped.loc[:, [        'price', 'topprizeodds', 'overallodds', 'Winning Tickets At Start', 'Winning Tickets Unclaimed']].apply(pd.to_numeric)    # create new 'prize amounts' of "$0" for non-prize tickets and "Total" for the sum of all tickets, then concat to scratcherstables    nonprizetix = gamesgrouped.loc[:,['gameNumber', 'gameName',                                'Non-prize at start', 'Non-prize remaining', 'dateexported']].copy()    nonprizetix.rename(columns={'Non-prize at start': 'Winning Tickets At Start',                       'Non-prize remaining': 'Winning Tickets Unclaimed'}, inplace=True)    nonprizetix.loc[:, 'prizeamount'] = 0    totals = gamesgrouped.loc[:,['gameNumber', 'gameName',                           'Total at start', 'Total remaining', 'dateexported']].copy()    totals.rename(columns={'Total at start': 'Winning Tickets At Start',                  'Total remaining': 'Winning Tickets Unclaimed'}, inplace=True)    totals.loc[:, 'prizeamount'] = "Total"    # loop through each scratcher game id number and add columns for each statistical calculation    alltables = pd.DataFrame()    currentodds = pd.DataFrame()    for gameid in gamesgrouped['gameNumber']:        gamerow = gamesgrouped.loc[(gamesgrouped['gameNumber'] == gameid), :]        startingtotal = int(gamerow.loc[:, 'Total at start'].values[0])        tixtotal = int(gamerow.loc[:, 'Total remaining'].values[0])        totalremain = scratchertables.loc[(scratchertables['gameNumber'] == gameid), [            'gameNumber', 'gameName', 'prizeamount', 'Winning Tickets At Start', 'Winning Tickets Unclaimed', 'dateexported']]        totalremain.loc[:, ['prizeamount', 'Winning Tickets At Start', 'Winning Tickets Unclaimed']] = totalremain.loc[:, [            'prizeamount', 'Winning Tickets At Start', 'Winning Tickets Unclaimed']].apply(pd.to_numeric)        price = int(gamerow['price'].values[0])        prizes = totalremain.loc[:, 'prizeamount']        # add various columns for the scratcher stats that go into the ratings table        gamerow.loc[:, 'Current Odds of Top Prize'] = gamerow.loc[:,                                                                  'topprizeodds']        gamerow.loc[:, 'Change in Current Odds of Top Prize'] = (gamerow.loc[:, 'Current Odds of Top Prize'] - float(            gamerow['topprizeodds'].values[0])) / float(gamerow['topprizeodds'].values[0])        gamerow.loc[:, 'Current Odds of Any Prize'] = tixtotal / \            sum(totalremain.loc[:, 'Winning Tickets Unclaimed'])        gamerow.loc[:, 'Change in Current Odds of Any Prize'] = (gamerow.loc[:, 'Current Odds of Any Prize'] - float(            gamerow['overallodds'].values[0])) / float(gamerow['overallodds'].values[0])        gamerow.loc[:, 'Odds of Profit Prize'] = tixtotal/sum(            totalremain.loc[totalremain['prizeamount'] != price, 'Winning Tickets Unclaimed'])        startingprofitodds = startingtotal / \            sum(totalremain.loc[totalremain['prizeamount']                != price, 'Winning Tickets At Start'])        gamerow.loc[:, 'Starting Odds of Profit Prize'] = startingprofitodds        gamerow.loc[:, 'Change in Odds of Profit Prize'] = (            gamerow.loc[:, 'Odds of Profit Prize'] - startingprofitodds) / startingprofitodds        gamerow.loc[:, 'Probability of Winning Any Prize'] = sum(            totalremain.loc[:, 'Winning Tickets Unclaimed'])/tixtotal        startprobanyprize = sum(            totalremain.loc[:, 'Winning Tickets At Start'])/startingtotal        gamerow.loc[:, 'Starting Probability of Winning Any Prize'] = startprobanyprize        gamerow.loc[:, 'Change in Probability of Any Prize'] = startprobanyprize - \            gamerow.loc[:, 'Probability of Winning Any Prize']        gamerow.loc[:, 'Probability of Winning Profit Prize'] = sum(            totalremain.loc[totalremain['prizeamount'] != price, 'Winning Tickets Unclaimed'])/tixtotal        startprobprofitprize = sum(            totalremain.loc[totalremain['prizeamount'] != price, 'Winning Tickets At Start'])/startingtotal        gamerow.loc[:, 'Starting Probability of Winning Profit Prize'] = startprobprofitprize        gamerow.loc[:, 'Change in Probability of Profit Prize'] = startprobprofitprize - \            gamerow.loc[:, 'Probability of Winning Profit Prize']        gamerow.loc[:, 'StdDev of All Prizes'] = totalremain.loc[:,                                                                 'Winning Tickets Unclaimed'].std().mean()/tixtotal        gamerow.loc[:, 'StdDev of Profit Prizes'] = totalremain.loc[totalremain['prizeamount']                                                                    != price, 'Winning Tickets Unclaimed'].std().mean()/tixtotal        gamerow.loc[:, 'Odds of Any Prize + 3 StdDevs'] = tixtotal / \            (gamerow.loc[:, 'Current Odds of Any Prize'] +             (totalremain.loc[:, 'Winning Tickets Unclaimed'].std().mean()*3))        gamerow.loc[:, 'Odds of Profit Prize + 3 StdDevs'] = tixtotal/(gamerow.loc[:, 'Odds of Profit Prize']+(            totalremain.loc[totalremain['prizeamount'] != price, 'Winning Tickets Unclaimed'].std().mean()*3))        gamerow.loc[:, 'Max Tickets to Buy'] = tixtotal/(totalremain.loc[totalremain['prizeamount'] != price, 'Winning Tickets Unclaimed'].sum(        )-totalremain.loc[totalremain['prizeamount'] != price, 'Winning Tickets Unclaimed'].std().mean())        # calculate expected value        totalremain.loc[:, ['prizeamount', 'Winning Tickets At Start', 'Winning Tickets Unclaimed']] = totalremain.loc[:, [            'prizeamount', 'Winning Tickets At Start', 'Winning Tickets Unclaimed']].apply(pd.to_numeric)        totalremain.loc[:, 'Starting Expected Value'] = totalremain.apply(lambda row: (            row['prizeamount']-price)*(row['Winning Tickets At Start']/startingtotal), axis=1)        totalremain.loc[:, 'Expected Value'] = totalremain.apply(lambda row: (            row['prizeamount']-price)*(row['Winning Tickets Unclaimed']/tixtotal), axis=1)        totalremain = totalremain.loc[:, ['gameNumber', 'gameName', 'prizeamount', 'Winning Tickets At Start',                                   'Winning Tickets Unclaimed', 'Starting Expected Value', 'Expected Value', 'dateexported']]        gamerow.loc[:, 'Expected Value of Any Prize (as % of cost)'] = sum(            totalremain['Expected Value'])/price if price > 0 else sum(totalremain['Expected Value'])        gamerow.loc[:, 'Change in Expected Value of Any Prize'] = ((sum(totalremain['Expected Value'])-sum(totalremain['Starting Expected Value']))/sum(            totalremain['Starting Expected Value']))/price if price > 0 else ((sum(totalremain['Expected Value'])-sum(totalremain['Starting Expected Value']))/sum(totalremain['Starting Expected Value']))        gamerow.loc[:, 'Expected Value of Profit Prize (as % of cost)'] = sum(            totalremain.loc[totalremain['prizeamount'] > price, 'Expected Value'])/price if price > 0 else sum(totalremain.loc[totalremain['prizeamount'] > price, 'Expected Value'])        gamerow.loc[:, 'Change in Expected Value of Profit Prize'] = ((sum(totalremain.loc[totalremain['prizeamount'] > price, 'Expected Value'])-sum(totalremain.loc[totalremain['prizeamount'] > price, 'Starting Expected Value']))/sum(totalremain.loc[totalremain['prizeamount'] > price, 'Starting Expected Value']))/price if price > 0 else (            sum(totalremain.loc[totalremain['prizeamount'] > price, 'Expected Value'])-sum(totalremain.loc[totalremain['prizeamount'] > price, 'Starting Expected Value']))/sum(totalremain.loc[totalremain['prizeamount'] > price, 'Starting Expected Value'])        gamerow.loc[:, 'Percent of Prizes Remaining'] = (            totalremain.loc[:, 'Winning Tickets Unclaimed']/totalremain.loc[:, 'Winning Tickets At Start']).mean()        gamerow.loc[:, 'Percent of Profit Prizes Remaining'] = (            totalremain.loc[totalremain['prizeamount'] > price, 'Winning Tickets Unclaimed']/totalremain.loc[totalremain['prizeamount'] > price, 'Winning Tickets At Start']).mean()        chngLosingTix = (gamerow.loc[:, 'Non-prize remaining']-gamerow.loc[:,                         'Non-prize at start'])/gamerow.loc[:, 'Non-prize at start']        chngAvailPrizes = (tixtotal-startingtotal)/startingtotal        try:            gamerow.loc[:,'Ratio of Decline in Prizes to Decline in Losing Ticket'] = chngLosingTix/chngAvailPrizes        except ZeroDivisionError:            gamerow.loc[:,'Ratio of Decline in Prizes to Decline in Losing Ticket'] = 0        gamerow.loc[:, 'Photo'] = tixlist.loc[tixlist['gameNumber']                                              == gameid, 'gamePhoto'].values[0]        gamerow.loc[:, 'FAQ'] = None        gamerow.loc[:, 'About'] = None        gamerow.loc[:, 'Directory'] = None        gamerow.loc[:, 'Data Date'] = gamerow.loc[:, 'dateexported']        currentodds = pd.concat([currentodds, gamerow], axis=0, ignore_index=True)        # add non-prize and totals rows with matching columns        totalremain.loc[:, 'Total remaining'] = tixtotal        totalremain.loc[:, 'Prize Probability'] = totalremain.loc[:,                                                                  'Winning Tickets Unclaimed']/totalremain.loc[:, 'Total remaining']        totalremain.loc[:, 'Percent Tix Remaining'] = totalremain.loc[:,                                                                      'Winning Tickets Unclaimed']/totalremain.loc[:, 'Winning Tickets At Start']        nonprizetix.loc[:, 'Prize Probability'] = nonprizetix.apply(lambda row: (            row['Winning Tickets Unclaimed']/tixtotal) if (row['gameNumber'] == gameid) & (row['Winning Tickets Unclaimed'] > 0) else 0, axis=1)        nonprizetix.loc[:, 'Percent Tix Remaining'] = nonprizetix.loc[nonprizetix['gameNumber'] == gameid,                                                                      'Winning Tickets Unclaimed']/nonprizetix.loc[nonprizetix['gameNumber'] == gameid, 'Winning Tickets At Start']        nonprizetix.loc[:, 'Starting Expected Value'] = (            nonprizetix['prizeamount']-price)*(nonprizetix['Winning Tickets At Start']/startingtotal)        nonprizetix.loc[:, 'Expected Value'] = (            nonprizetix['prizeamount']-price)*(nonprizetix['Winning Tickets Unclaimed']/tixtotal)        totals.loc[:, 'Prize Probability'] = totals.loc[totals['gameNumber']                                                        == gameid, 'Winning Tickets Unclaimed']/tixtotal        totals.loc[:, 'Percent Tix Remaining'] = totals.loc[totals['gameNumber'] == gameid,                                                            'Winning Tickets Unclaimed']/totals.loc[totals['gameNumber'] == gameid, 'Winning Tickets At Start']        totals.loc[:, 'Starting Expected Value'] = ''        totals.loc[:, 'Expected Value'] = ''        totalremain = totalremain.loc[:, ['gameNumber', 'gameName', 'prizeamount', 'Winning Tickets At Start', 'Winning Tickets Unclaimed',                                   'Prize Probability', 'Percent Tix Remaining', 'Starting Expected Value', 'Expected Value', 'dateexported']]        totalremain = pd.concat([totalremain, nonprizetix.loc[nonprizetix['gameNumber'] == gameid, ['gameNumber', 'gameName', 'prizeamount', 'Winning Tickets At Start',                                         'Winning Tickets Unclaimed', 'Prize Probability', 'Percent Tix Remaining', 'Starting Expected Value', 'Expected Value', 'dateexported']]], axis=0, ignore_index=True)        totalremain = pd.concat([totalremain, totals.loc[totals['gameNumber'] == gameid, ['gameNumber', 'gameName', 'prizeamount', 'Winning Tickets At Start',                                         'Winning Tickets Unclaimed', 'Prize Probability', 'Percent Tix Remaining', 'Starting Expected Value', 'Expected Value', 'dateexported']]], axis=0, ignore_index=True)        # add expected values for final totals row        allexcepttotal = totalremain.loc[totalremain['prizeamount'] != 'Total', :]        totalremain.loc[totalremain['prizeamount'] != 'Total', 'Starting Expected Value'] = allexcepttotal.apply(            lambda row: (row['prizeamount']-price)*(row['Winning Tickets At Start']/startingtotal), axis=1)        totalremain.loc[totalremain['prizeamount'] != 'Total', 'Expected Value'] = allexcepttotal.apply(            lambda row: (row['prizeamount']-price)*(row['Winning Tickets Unclaimed']/tixtotal), axis=1)        alltables = pd.concat([alltables, totalremain], axis=0)    scratchertables = alltables.loc[:, ['gameNumber', 'gameName', 'prizeamount', 'Winning Tickets At Start', 'Winning Tickets Unclaimed',                                 'Prize Probability', 'Percent Tix Remaining', 'Starting Expected Value', 'Expected Value', 'dateexported']]    # save scratchers tables    #scratchertables.to_sql('MOscratcherstables', engine, if_exists='replace')    scratchertables.to_csv("./MOscratchertables.csv", encoding='utf-8')    # create rankings table by merging the list with the tables    scratchersall.loc[:, 'price'] = scratchersall.loc[:,                                                      'price'].apply(pd.to_numeric)    ratingstable = scratchersall.merge(        currentodds, how='left', on=['gameNumber', 'price'])    ratingstable.drop(labels=['gameName_x', 'dateexported_y', 'overallodds_y',                      'topprizeremain_x'], axis=1, inplace=True)    ratingstable.rename(columns={'gameName_y': 'gameName', 'dateexported_x': 'dateexported', 'topprizeodds_x': 'topprizeodds',                        'overallodds_x': 'overallodds', 'topprizeremain_y': 'topprizeremain'}, inplace=True)        # --- Start of FIX for date parsing ---    # Define the expected format for 'startDate' for Missouri Lottery    mo_start_date_format = "%b. %d, %Y" # e.g., "Apr. 28, 2025"    # Convert 'dateexported' and 'startDate' to datetime series.    # 'dateexported' contains Python date objects from date.today(), pd.to_datetime handles these.    # 'startDate' contains strings that need the specified format.    # Using errors='coerce' will turn unparseable dates into NaT.        # Prepare default NaT series in case columns are missing (defensive coding)    col_dateexported_dt = pd.Series([pd.NaT] * len(ratingstable), index=ratingstable.index)     if 'dateexported' in ratingstable.columns:        col_dateexported_dt = pd.to_datetime(ratingstable['dateexported'], errors='coerce')    col_startDate_dt = pd.Series([pd.NaT] * len(ratingstable), index=ratingstable.index)    if 'startDate' in ratingstable.columns:        col_startDate_dt = pd.to_datetime(ratingstable['startDate'], format=mo_start_date_format, errors='coerce')        # Original print statements for debugging (can be removed or updated)    # print(col_dateexported_dt.dtype)    # print(col_startDate_dt.dtype)        # Calculate 'Days Since Start' using the converted datetime series    ratingstable.loc[:, 'Days Since Start'] = (col_dateexported_dt - col_startDate_dt).dt.days    # --- End of FIX for date parsing ---        # add rankings columns of all scratchers to ratings table    ratingstable['Rank by Best Probability of Winning Any Prize'] = (ratingstable['Current Odds of Any Prize'].rank(    )+ratingstable['Probability of Winning Any Prize'].rank()+ratingstable['Odds of Any Prize + 3 StdDevs'].rank())/3    ratingstable['Rank by Best Probability of Winning Profit Prize'] = (ratingstable['Odds of Profit Prize'].rank(    )+ratingstable['Probability of Winning Profit Prize'].rank()+ratingstable['Odds of Profit Prize + 3 StdDevs'].rank())/3    ratingstable['Rank by Least Expected Losses'] = (ratingstable['Expected Value of Any Prize (as % of cost)'].rank(    )+ratingstable['Expected Value of Profit Prize (as % of cost)'].rank())/2    ratingstable['Rank by Most Available Prizes'] = (ratingstable['Percent of Prizes Remaining'].rank(    )+ratingstable['Percent of Profit Prizes Remaining'].rank()+ratingstable['Ratio of Decline in Prizes to Decline in Losing Ticket'].rank())/3    ratingstable['Rank by Best Change in Probabilities'] = (ratingstable['Change in Current Odds of Any Prize'].rank()+ratingstable['Change in Current Odds of Top Prize'].rank()                                                            + ratingstable['Change in Probability of Any Prize'].rank(    )+ratingstable['Change in Probability of Profit Prize'].rank()        + ratingstable['Expected Value of Any Prize (as % of cost)'].rank()+ratingstable['Expected Value of Profit Prize (as % of cost)'].rank())/6    ratingstable.loc[:, 'Rank Average'] = ratingstable.loc[:,                                                           'Rank by Best Probability of Winning Any Prize':'Rank by Best Change in Probabilities'].mean(axis=1)    ratingstable.loc[:, 'Overall Rank'] = ratingstable.loc[:,                                                           'Rank Average'].rank()    ratingstable.loc[:, 'Rank by Cost'] = ratingstable.groupby(        'price')['Overall Rank'].rank('dense', ascending=True)    # columns in ratingstable to round to only two decimals    twodecimalcols = ['Current Odds of Any Prize', 'Odds of Profit Prize',                      'Percent of Prizes Remaining', 'Expected Value of Any Prize (as % of cost)']    ratingstable[twodecimalcols] = ratingstable[twodecimalcols].round(2)    ratingstable['Max Tickets to Buy'] = ratingstable['Max Tickets to Buy'].round(        0)    # save ratingstable    ratingstable['Stats Page'] = "/missouri-statistics-for-each-scratcher-game"    #ratingstable.to_sql('MOratingstable', engine, if_exists='replace')    ratingstable.to_csv("./MOratingstable.csv", encoding='utf-8')    ratingstable = ratingstable.loc[:, ['price', 'gameName', 'gameNumber', 'topprize', 'topprizeremain', 'topprizeavail', 'extrachances', 'secondChance',                                 'startDate', 'Days Since Start', 'lastdatetoclaim', 'topprizeodds', 'overallodds', 'Current Odds of Top Prize',                                 'Change in Current Odds of Top Prize', 'Current Odds of Any Prize',                                 'Change in Current Odds of Any Prize', 'Odds of Profit Prize', 'Change in Odds of Profit Prize',                                 'Probability of Winning Any Prize', 'Change in Probability of Any Prize',                                 'Probability of Winning Profit Prize', 'Change in Probability of Profit Prize',                                 'StdDev of All Prizes', 'StdDev of Profit Prizes', 'Odds of Any Prize + 3 StdDevs',                                 'Odds of Profit Prize + 3 StdDevs', 'Max Tickets to Buy',                                 'Expected Value of Any Prize (as % of cost)',                                 'Change in Expected Value of Any Prize',                                 'Expected Value of Profit Prize (as % of cost)',                                 'Change in Expected Value of Profit Prize',                                 'Percent of Prizes Remaining', 'Percent of Profit Prizes Remaining',                                 'Ratio of Decline in Prizes to Decline in Losing Ticket',                                 'Rank by Best Probability of Winning Any Prize',                                 'Rank by Best Probability of Winning Profit Prize',                                 'Rank by Least Expected Losses', 'Rank by Most Available Prizes',                                 'Rank by Best Change in Probabilities', 'Rank Average', 'Overall Rank', 'Rank by Cost',                                 'Photo', 'FAQ', 'About', 'Directory',                                 'Data Date', 'Stats Page','gameURL']]    ratingstable.replace([np.inf, -np.inf], 0, inplace=True)    ratingstable.fillna('', inplace=True)    return ratingstable, scratchertablesexportScratcherRecs()